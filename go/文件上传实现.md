# Go æ–‡ä»¶ä¸Šä¼ å®ç°

> ğŸ”— **å…³è”ç¬”è®°**ï¼š[[ç•™è¨€ç³»ç»Ÿé¡¹ç›®å®æˆ˜]]
> ğŸ“… **åˆ›å»ºæ—¶é—´**ï¼š2024-12-24

---

## ğŸ“– æ¦‚è¿°

ä¸ºç•™è¨€ç³»ç»Ÿæ·»åŠ æ–‡ä»¶ä¸Šä¼ åŠŸèƒ½ï¼Œæ”¯æŒä¸Šä¼ å›¾ç‰‡é™„ä»¶åˆ°ç•™è¨€ä¸­ã€‚

---

## ğŸ› ï¸ å®ç°æ­¥éª¤

### 1. åˆ›å»ºä¸Šä¼ ç›®å½•ç»“æ„

```bash
mkdir -p uploads/images
```

### 2. æ–‡ä»¶æ¨¡å‹

```go
// models/attachment.go
package models

import "time"

// Attachment é™„ä»¶æ¨¡å‹
type Attachment struct {
	ID        uint      `json:"id" gorm:"primaryKey"`
	MessageID uint      `json:"message_id" gorm:"index"`           // å…³è”çš„ç•™è¨€ID
	Filename  string    `json:"filename" gorm:"size:255;not null"` // åŸå§‹æ–‡ä»¶å
	FilePath  string    `json:"file_path" gorm:"size:500;not null"`// å­˜å‚¨è·¯å¾„
	FileSize  int64     `json:"file_size"`                         // æ–‡ä»¶å¤§å° (å­—èŠ‚)
	MimeType  string    `json:"mime_type" gorm:"size:100"`         // MIMEç±»å‹
	CreatedAt time.Time `json:"created_at"`
}

// TableName è‡ªå®šä¹‰è¡¨å
func (Attachment) TableName() string {
	return "attachments"
}
```

### 3. æ›´æ–°ç•™è¨€æ¨¡å‹

```go
// models/message.go
type Message struct {
	// ... å…¶ä»–å­—æ®µ
	Attachments []Attachment `json:"attachments" gorm:"foreignKey:MessageID"`
}
```

### 4. æ–‡ä»¶ä¸Šä¼ å¤„ç†å™¨

```go
// handlers/upload.go
package handlers

import (
	"fmt"
	"message-board/config"
	"message-board/models"
	"net/http"
	"path/filepath"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
)

// å…è®¸çš„æ–‡ä»¶ç±»å‹
var allowedMimeTypes = map[string]bool{
	"image/jpeg": true,
	"image/png":  true,
	"image/gif":  true,
	"image/webp": true,
}

// æœ€å¤§æ–‡ä»¶å¤§å° (5MB)
const maxFileSize = 5 * 1024 * 1024

// UploadFile ä¸Šä¼ å•ä¸ªæ–‡ä»¶
func UploadFile(c *gin.Context) {
	// è·å–ä¸Šä¼ çš„æ–‡ä»¶
	file, err := c.FormFile("file")
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "è¯·é€‰æ‹©è¦ä¸Šä¼ çš„æ–‡ä»¶"})
		return
	}
	
	// æ£€æŸ¥æ–‡ä»¶å¤§å°
	if file.Size > maxFileSize {
		c.JSON(http.StatusBadRequest, gin.H{"error": "æ–‡ä»¶å¤§å°ä¸èƒ½è¶…è¿‡ 5MB"})
		return
	}
	
	// æ£€æŸ¥æ–‡ä»¶ç±»å‹
	mimeType := file.Header.Get("Content-Type")
	if !allowedMimeTypes[mimeType] {
		c.JSON(http.StatusBadRequest, gin.H{"error": "ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹"})
		return
	}
	
	// ç”Ÿæˆå”¯ä¸€æ–‡ä»¶å
	ext := filepath.Ext(file.Filename)
	newFilename := fmt.Sprintf("%s_%s%s", 
		time.Now().Format("20060102"), 
		uuid.New().String()[:8], 
		ext,
	)
	
	// ä¿å­˜è·¯å¾„
	uploadPath := filepath.Join("uploads", "images", newFilename)
	
	// ä¿å­˜æ–‡ä»¶
	if err := c.SaveUploadedFile(file, uploadPath); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "æ–‡ä»¶ä¿å­˜å¤±è´¥"})
		return
	}
	
	// è®°å½•åˆ°æ•°æ®åº“
	attachment := models.Attachment{
		Filename: file.Filename,
		FilePath: uploadPath,
		FileSize: file.Size,
		MimeType: mimeType,
	}
	config.DB.Create(&attachment)
	
	c.JSON(http.StatusOK, gin.H{
		"message": "ä¸Šä¼ æˆåŠŸ",
		"data": gin.H{
			"id":       attachment.ID,
			"filename": file.Filename,
			"url":      "/" + uploadPath,
			"size":     file.Size,
		},
	})
}

// UploadMultipleFiles ä¸Šä¼ å¤šä¸ªæ–‡ä»¶
func UploadMultipleFiles(c *gin.Context) {
	form, err := c.MultipartForm()
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "æ— æ³•è§£æè¡¨å•"})
		return
	}
	
	files := form.File["files"]
	if len(files) == 0 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "è¯·é€‰æ‹©è¦ä¸Šä¼ çš„æ–‡ä»¶"})
		return
	}
	
	var uploaded []gin.H
	
	for _, file := range files {
		// æ£€æŸ¥å¤§å°å’Œç±»å‹
		if file.Size > maxFileSize {
			continue
		}
		mimeType := file.Header.Get("Content-Type")
		if !allowedMimeTypes[mimeType] {
			continue
		}
		
		// ç”Ÿæˆæ–‡ä»¶åå¹¶ä¿å­˜
		ext := filepath.Ext(file.Filename)
		newFilename := fmt.Sprintf("%s_%s%s",
			time.Now().Format("20060102"),
			uuid.New().String()[:8],
			ext,
		)
		uploadPath := filepath.Join("uploads", "images", newFilename)
		
		if err := c.SaveUploadedFile(file, uploadPath); err != nil {
			continue
		}
		
		// è®°å½•åˆ°æ•°æ®åº“
		attachment := models.Attachment{
			Filename: file.Filename,
			FilePath: uploadPath,
			FileSize: file.Size,
			MimeType: mimeType,
		}
		config.DB.Create(&attachment)
		
		uploaded = append(uploaded, gin.H{
			"id":       attachment.ID,
			"filename": file.Filename,
			"url":      "/" + uploadPath,
		})
	}
	
	c.JSON(http.StatusOK, gin.H{
		"message": fmt.Sprintf("æˆåŠŸä¸Šä¼  %d ä¸ªæ–‡ä»¶", len(uploaded)),
		"data":    uploaded,
	})
}

// CreateMessageWithAttachment åˆ›å»ºå¸¦é™„ä»¶çš„ç•™è¨€
func CreateMessageWithAttachment(c *gin.Context) {
	// è§£æè¡¨å•æ•°æ®
	author := c.PostForm("author")
	content := c.PostForm("content")
	
	if author == "" || content == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "è¯·å¡«å†™ä½œè€…å’Œå†…å®¹"})
		return
	}
	
	// åˆ›å»ºç•™è¨€
	message := models.Message{
		Author:  author,
		Content: content,
	}
	config.DB.Create(&message)
	
	// å¤„ç†é™„ä»¶
	form, _ := c.MultipartForm()
	if form != nil {
		files := form.File["attachments"]
		for _, file := range files {
			if file.Size > maxFileSize {
				continue
			}
			
			ext := filepath.Ext(file.Filename)
			newFilename := fmt.Sprintf("%s_%s%s",
				time.Now().Format("20060102"),
				uuid.New().String()[:8],
				ext,
			)
			uploadPath := filepath.Join("uploads", "images", newFilename)
			
			if err := c.SaveUploadedFile(file, uploadPath); err != nil {
				continue
			}
			
			attachment := models.Attachment{
				MessageID: message.ID,
				Filename:  file.Filename,
				FilePath:  uploadPath,
				FileSize:  file.Size,
				MimeType:  file.Header.Get("Content-Type"),
			}
			config.DB.Create(&attachment)
		}
	}
	
	// é‡æ–°åŠ è½½ç•™è¨€ (åŒ…å«é™„ä»¶)
	config.DB.Preload("Attachments").First(&message, message.ID)
	
	c.JSON(http.StatusCreated, gin.H{
		"message": "ç•™è¨€åˆ›å»ºæˆåŠŸ",
		"data":    message,
	})
}
```

### 5. é…ç½®è·¯ç”±å’Œé™æ€æ–‡ä»¶

```go
// routes/routes.go
func SetupRoutes(r *gin.Engine) {
	// é™æ€æ–‡ä»¶æœåŠ¡ (è®¿é—®ä¸Šä¼ çš„å›¾ç‰‡)
	r.Static("/uploads", "./uploads")
	
	api := r.Group("/api")
	{
		// æ–‡ä»¶ä¸Šä¼ 
		api.POST("/upload", handlers.UploadFile)
		api.POST("/upload/multiple", handlers.UploadMultipleFiles)
		
		// å¸¦é™„ä»¶çš„ç•™è¨€
		api.POST("/messages/with-attachment", handlers.CreateMessageWithAttachment)
	}
}
```

---

## ğŸ§ª æµ‹è¯•ç¤ºä¾‹

```bash
# 1. ä¸Šä¼ å•ä¸ªæ–‡ä»¶
curl -X POST http://localhost:8080/api/upload \
  -F "file=@/path/to/image.jpg"

# 2. ä¸Šä¼ å¤šä¸ªæ–‡ä»¶
curl -X POST http://localhost:8080/api/upload/multiple \
  -F "files=@/path/to/image1.jpg" \
  -F "files=@/path/to/image2.png"

# 3. åˆ›å»ºå¸¦é™„ä»¶çš„ç•™è¨€
curl -X POST http://localhost:8080/api/messages/with-attachment \
  -F "author=å¼ ä¸‰" \
  -F "content=è¿™æ˜¯å¸¦å›¾ç‰‡çš„ç•™è¨€" \
  -F "attachments=@/path/to/image.jpg"

# 4. è®¿é—®ä¸Šä¼ çš„å›¾ç‰‡
curl http://localhost:8080/uploads/images/20241224_abc12345.jpg
```

---

## ğŸ” å®‰å…¨å»ºè®®

1. **æ–‡ä»¶ç±»å‹éªŒè¯**ï¼šæ£€æŸ¥æ–‡ä»¶ Magic Numberï¼Œä¸ä»…ä»…æ˜¯æ‰©å±•å
2. **æ–‡ä»¶å¤§å°é™åˆ¶**ï¼šè®¾ç½®åˆç†çš„ä¸Šä¼ å¤§å°é™åˆ¶
3. **å­˜å‚¨è·¯å¾„**ï¼šä¸è¦å°†æ–‡ä»¶å­˜å‚¨åœ¨ Web å¯æ‰§è¡Œç›®å½•
4. **æ–‡ä»¶å**ï¼šä½¿ç”¨ UUID é‡å‘½åï¼Œé¿å…è·¯å¾„éå†æ”»å‡»
5. **ç—…æ¯’æ‰«æ**ï¼šç”Ÿäº§ç¯å¢ƒè€ƒè™‘é›†æˆç—…æ¯’æ‰«æ

---

## ğŸ“š ç›¸å…³ç¬”è®°

- [[ç•™è¨€ç³»ç»Ÿé¡¹ç›®å®æˆ˜]] - ä¸»é¡¹ç›®
- [[JWTç”¨æˆ·è®¤è¯]] - ç”¨æˆ·è®¤è¯

---

#Go #Gin #æ–‡ä»¶ä¸Šä¼  #åç«¯å¼€å‘
