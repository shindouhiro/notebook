# ç»„ä»¶å®ä¾‹åŒ–æµç¨‹

> ğŸ”— **å…³è”ç¬”è®°**ï¼š[[Vue3æºç å®æˆ˜ç¬”è®°]]
> ğŸ“… **åˆ›å»ºæ—¶é—´**ï¼š2024-12-24
> ğŸ“ **æºç ä½ç½®**ï¼š`packages/runtime-core/src/component.ts`

---

## ğŸ“– ç»„ä»¶æŒ‚è½½æµç¨‹

```mermaid
graph TD
    A[createApp] --> B[mount]
    B --> C[render]
    C --> D[patch]
    D --> E[processComponent]
    E --> F[mountComponent]
    F --> G[createComponentInstance]
    G --> H[setupComponent]
    H --> I[setupRenderEffect]
    I --> J[ç»„ä»¶æ¸²æŸ“å®Œæˆ]
```

---

## ğŸ”§ æ ¸å¿ƒæ­¥éª¤

### 1. åˆ›å»ºç»„ä»¶å®ä¾‹

```typescript
function createComponentInstance(vnode, parent) {
  const instance = {
    vnode,
    type: vnode.type,
    parent,
    
    // çŠ¶æ€
    data: {},
    props: {},
    attrs: {},
    slots: {},
    
    // ç”Ÿå‘½å‘¨æœŸ
    isMounted: false,
    
    // æ¸²æŸ“ç›¸å…³
    render: null,
    proxy: null,
    
    // å…¶ä»–
    emit: null,
    provides: parent ? parent.provides : {}
  }
  
  instance.emit = emit.bind(null, instance)
  
  return instance
}
```

### 2. åˆå§‹åŒ–ç»„ä»¶

```typescript
function setupComponent(instance) {
  const { props, children } = instance.vnode
  
  // åˆå§‹åŒ– props
  initProps(instance, props)
  
  // åˆå§‹åŒ– slots
  initSlots(instance, children)
  
  // è°ƒç”¨ setup
  setupStatefulComponent(instance)
}

function setupStatefulComponent(instance) {
  const Component = instance.type
  
  // åˆ›å»ºä»£ç†
  instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers)
  
  const { setup } = Component
  if (setup) {
    const setupResult = setup(instance.props, {
      attrs: instance.attrs,
      slots: instance.slots,
      emit: instance.emit
    })
    
    handleSetupResult(instance, setupResult)
  }
}
```

### 3. è®¾ç½®æ¸²æŸ“ Effect

```typescript
function setupRenderEffect(instance, container) {
  const componentUpdateFn = () => {
    if (!instance.isMounted) {
      // é¦–æ¬¡æŒ‚è½½
      const subTree = (instance.subTree = instance.render.call(instance.proxy))
      patch(null, subTree, container)
      instance.isMounted = true
    } else {
      // æ›´æ–°
      const nextTree = instance.render.call(instance.proxy)
      const prevTree = instance.subTree
      instance.subTree = nextTree
      patch(prevTree, nextTree, container)
    }
  }
  
  const effect = new ReactiveEffect(componentUpdateFn, () => {
    queueJob(instance.update)
  })
  
  instance.update = effect.run.bind(effect)
  instance.update()
}
```

---

## ğŸ“š ç›¸å…³ç¬”è®°

- [[Vue3æºç å®æˆ˜ç¬”è®°]] - ä¸»ç¬”è®°
- [[ç”Ÿå‘½å‘¨æœŸå®ç°]] - ç”Ÿå‘½å‘¨æœŸ
- [[Propså’ŒEmit]] - ç»„ä»¶é€šä¿¡

#Vue3 #ç»„ä»¶ #æºç åˆ†æ
